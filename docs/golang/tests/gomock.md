---
title: "golang 单元测试 gomock"
icon: golang2
---
## 简介

GoMock是由Golang官方开发维护的测试框架，实现了较为完整的基于interface的Mock功能，能够与Golang内置的testing包良好集成，也能用于其它的测试环境中。GoMock测试框架包含了GoMock包和mockgen工具两部分，其中GoMock包完成对桩对象生命周期的管理，mockgen工具用来生成interface对应的Mock类源文件。

GoMock官网: [github](https://github.com/golang/mock)

## 安装使用

### 安装 mockgen

### Go version < 1.16

```sh
GO111MODULE=on go get github.com/golang/mock/mockgen@v1.6.0
```

### Go 1.16+

```sh
go install github.com/golang/mock/mockgen@v1.6.0
```

### mockgen辅助代码生成工具安装

```sh
go install github.com/golang/mock/mockgen@latest
```

## mockgen 的参数说明

在使用 mockgen 生成模拟对象（Mock Objects）时，通常需要指定主要的参数

* -source：这是你想要生成模拟对象的接口定义所在的文件路径。
* -destination：生成的源代码写入的文件。如果不设置此项，代码将打印到标准输出。
* -package：用于生成的模拟类源代码的包名。如果不设置此项包名默认在原包名前添加mock_前缀。

* -imports：在生成的源代码中使用的显式导入列表。值为foo=bar/baz形式的逗号分隔的元素列表，其中bar/baz是要导入的包，foo是要在生成的源代码中用于包的标识符。
* -aux_files：需要参考以解决的附加文件列表，例如在不同文件中定义的嵌入式接口。指定的值应为foo=bar/baz.go形式的以逗号分隔的元素列表，其中bar/baz.go是源文件，foo是-source文件使用的文件的包名。
* -build_flags：（仅反射模式）一字不差地传递标志给go build
* -mock_names：生成的模拟的自定义名称列表。这被指定为一个逗号分隔的元素列表，形式为Repository = MockSensorRepository,Endpoint=MockSensorEndpoint，其中Repository是接口名称，mockSensorrepository 是所需的mock名称(mock工厂方法和mock记录器将以mock命名)。如果其中一个接口没有指定自定义名称，则将使用默认命名约定。

* -self_package：生成的代码的完整包导入路径。使用此flag的目的是通过尝试包含自己的包来防止生成代码中的循环导入。如果mock的包被设置为它的一个输入(通常是主输入)，并且输出是stdio，那么mockgen就无法检测到最终的输出包，这种情况就会发生。设置此标志将告诉 mockgen 排除哪个导入
* -copyright_file：用于将版权标头添加到生成的源代码中的版权文件
* -debug_parser：仅打印解析器结果
* -exec_only：（反射模式） 如果设置，则执行此反射程序
* -prog_only：（反射模式）只生成反射程序；将其写入标准输出并退出。
* -write_package_comment：如果为true，则写入包文档注释 (godoc)。（默认为true）

## 例子

### 1. 定义 user_service.gp

```go
package demo

import (
	"fmt"
	"strconv"
)

//go:generate mockgen -destination user_service_mock.go -package demo -source user_service.go

type UserSrv interface {
	GetUserById(id int) string
	Update(id int, data interface{}) (string, error)
}


type UserService struct {
}

func NewUserService() *UserService {
	return &UserService{}
}

func (u *UserService) GetUserById(id int) string {
	return strconv.Itoa(id)
}

func (u *UserService) Update(id int, data interface{}) (string, error) {
	str := u.GetUserById(id)
	return str, nil
}
```

### 2. 命令为接口生成 mock 实现

```sh
mockgen -destination=user_service_mock.go -package=unittest -source=user_service.go
```

### 3. 生成 user_service_mock.go 文件
```go
// Code generated by MockGen. DO NOT EDIT.
// Source: user_service.go

// Package demo is a generated GoMock package.
package demo

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockUserSrv is a mock of UserSrv interface.
type MockUserSrv struct {
	ctrl     *gomock.Controller
	recorder *MockUserSrvMockRecorder
}

// MockUserSrvMockRecorder is the mock recorder for MockUserSrv.
type MockUserSrvMockRecorder struct {
	mock *MockUserSrv
}

// NewMockUserSrv creates a new mock instance.
func NewMockUserSrv(ctrl *gomock.Controller) *MockUserSrv {
	mock := &MockUserSrv{ctrl: ctrl}
	mock.recorder = &MockUserSrvMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserSrv) EXPECT() *MockUserSrvMockRecorder {
	return m.recorder
}

// GetUserById mocks base method.
func (m *MockUserSrv) GetUserById(id int) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserById", id)
	ret0, _ := ret[0].(string)
	return ret0
}

// GetUserById indicates an expected call of GetUserById.
func (mr *MockUserSrvMockRecorder) GetUserById(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserById", reflect.TypeOf((*MockUserSrv)(nil).GetUserById), id)
}

// Update mocks base method.
func (m *MockUserSrv) Update(id int, data interface{}) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", id, data)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockUserSrvMockRecorder) Update(id, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserSrv)(nil).Update), id, data)
}

```

### 4.编辑写测试文件 user_service_test.go

```go
package demo

import (
	"fmt"
	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"testing"
)

func Test_GetUserById(t *testing.T) {
	//初始化一个mock controller
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockObj := NewMockUserSrv(ctrl)
	// mock方法调用次数支持如下
	mockObj.EXPECT().GetUserById(gomock.Any()).Return("11").AnyTimes()
	str := mockObj.GetUserById(11)
	
	// 判断结果
	assert.NotEmpty(t, str)   // 断言 str 不为空
	assert.Equal(t, "11", str) // 断言 str 的值等于 ”11“
}
// 测试 update

func Test_Update(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockObj := NewMockUserSrv(ctrl)

	mockObj.EXPECT().GetUserById(gomock.Any()).Return("11").AnyTimes()

	//mockObj.EXPECT().Update(gomock.Any(), gomock.Any()).Return("1", nil).AnyTimes()

	src := NewUserService()
	str, err := src.Update(11, "11")
	assert.NoError(t, err)
	assert.NotEmpty(t, str)
	assert.Equal(t, "11", str)
}
```

解析上面的代码：

1. Test_GetUserById 函数
   * 首先，创建了一个 gomock 控制器 ctrl，并在函数结束时通过 defer ctrl.Finish() 来确保在测试结束时进行必要的清理工作。

   * 然后，创建了一个模拟的 UserSrv 对象 mockObj。

   * 使用 EXPECT().GetUserById(gomock.Any()).Return("11").AnyTimes() 来设置对 GetUserById 方法的模拟行为。这里表示无论传入任何参数，该方法都将返回 "11"，并且调用次数没有限制。

   * 调用 mockObj.GetUserById(11) 来执行模拟的方法，并将结果存储在 str 变量中。

   * 最后，使用 assert.NotEmpty(t, str) 断言 str 不为空，使用 assert.Equal(t, "11", str) 断言 str 的值等于 "11"。

2. Test_Update 函数
   * 与 Test_GetUserById 函数类似，创建了控制器并在结束时进行清理。
   * 同样设置了对 GetUserById 方法的模拟行为。
   * 然后创建了实际的 UserService 对象 src，调用其 Update 方法，并获取返回的结果 str 和错误 err。
   * 使用 assert.NoError(t, err) 断言没有错误发生，使用 assert.NotEmpty(t, str) 断言 str 不为空，使用 assert.Equal(t, "11", str) 断言 str 的值等于 "11"。

总的来说，这段单元测试代码通过模拟服务方法的行为，对相关功能的结果进行了断言验证，以确保代码的正确性和稳定性。

### 5.测试

```sh
➜  demo go test .
ok    github.com/costa92/test/demo    0.335s
```

### 6.测试覆盖率

```go
go test -cover
```

### 7. 可视化界面

1. 生成测试覆盖率的 profile 文件
   
 ```sh
 go test . -coverprofile=cover.out
 ```

2. 利用 go 工具 profile 文件生成可视化界面

```sh
go tool cover -html=cover.out
```

3. 查看可视化界面   
![20240728233014](https://costa92.oss-cn-hangzhou.aliyuncs.com/Blog/20240728233014.png)

## mock/gomock 中使用函数说明

自定义mock实现主要包含了自定义参数，自定义返回值，自定义mock调用次数以及调用顺序

### （1）自定义参数

参数支持Eq,Any,Not,Nil，分别代表一下含义：

* Eq(value) 用于参数为固定值的场景。
* Any() 用于任意参数的场景。
* Not(value) 用于表示参数非 value 以外的值场景。
* Nil()  用于表示参数None 值的场景

```go
m.EXPECT().Get(gomock.Eq("Tom")).Return(0, errors.New("not exist"))
m.EXPECT().Get(gomock.Any()).Return(630, nil)
m.EXPECT().Get(gomock.Not("Sam")).Return(0, nil) 
m.EXPECT().Get(gomock.Nil()).Return(0, errors.New("nil")) 
```

### （2）自定义返回值

返回值支持如下几种：

* Return 用于返回确定的值的场景
* Do 用于无返回值的场景。
* DoAndReturn 用于可以动态地控制返回值。
  
```go
m.EXPECT().Get(gomock.Not("Sam")).Return(0, nil)
m.EXPECT().Get(gomock.Any()).Do(func(key string) {
    t.Log(key)
})
m.EXPECT().Get(gomock.Any()).DoAndReturn(func(key string) (int, error) {
    if key == "Sam" {
        return 630, nil
    }
    return 0, errors.New("not exist")
})
```

### （3）自定义mock调用次数

mock调用次数支持如下几种场景：

* Times() 断言 Mock 方法被调用的次数, 指定次数。
* MaxTimes() 最大次数。
* MinTimes() 最小次数。
* AnyTimes() 任意次数（包括 0 次）

```go
func TestGetFromDB(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	m := NewMockDB(ctrl)
	m.EXPECT().Get(gomock.Not("Sam")).Return(0, nil).Times(2)
	GetFromDB(m, "ABC")
	GetFromDB(m, "DEF")
}
```

### （4）自定义mock调用顺序

当存在多个mock之间相互调用的情况时，可以通过一下2种方式定义mock执行的顺序：

* 通过After关键字来实现保序
* 通过InOrder关键字来实现保序
  
```go
func TestGetFromDB(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用

	m := NewMockDB(ctrl)
	o1 := m.EXPECT().Get(gomock.Eq("Tom")).Return(0, errors.New("not exist"))
	o2 := m.EXPECT().Get(gomock.Eq("Sam")).Return(630, nil)
	gomock.InOrder(o1, o2)
	GetFromDB(m, "Tom")
	GetFromDB(m, "Sam")
}
```

### 注意： 如果定义的 interface 包含另外一个 interface  并且不是同一个文件的情况
如果在  interface 包含另外一个 interface  并且不是同一个文件的情况，使用 mockgen 的时候需要使用 -aux_files 参数，可以参考下面代码

1. 新建 user_service.go 文件

```go
package demo

import (
	"strconv"
)

// https://blog.csdn.net/u013276277/article/details/104993370

//go:generate mockgen -destination=user_service_mock.go  -package=demo  -aux_files=github.com/costa92/test/demo=user_info.go -source=user_service.go
type UserSrv interface {
	GetUserById(id int) string
	Update(id int, data interface{}) (string, error)

	UserInfoSrv
}

type UserService struct {
}

func NewUserService() *UserService {
	return &UserService{}
}

func (u *UserService) GetUserById(id int) string {
	return strconv.Itoa(id)
}

func (u *UserService) Update(id int, data interface{}) (string, error) {
	str := u.GetUserById(id)
	return str, nil
}

``` 
2. 新建 user_info.go

```go
package demo

import "strconv"

type UserInfoSrv interface {
	GetUserInfoById11(id int) string
}

func (u *UserService) GetUserInfoById11(id int) string {
	return strconv.Itoa(id)
}

```
在 user_service.go 文件中使用 user_info.go 的  UserInfoSrv 的 interface

所以生成mock 的命令需要改成：

```sh
 mockgen -destination=user_service_mock.go  -package=demo  -aux_files=github.com/costa92/test/demo=user_info.go -source=user_service.go
 ```

* `github.com/costa92/test/demo` 是包名
* `user_info.go` 是 interface 定义的文件

## 参考：

[golang-unit-test](https://zhangyuyu.github.io/golang-unit-test/)
[gomock github](https://github.com/golang/mock)